// --stats.chk------------------------------------------------------------------
//
//  File containing parameter checking functions for stats.cpp.
//
// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved.
// -----------------------------------------------------------------------------

#ifndef DEBUG

#define CHK_HrOpenFolderMetrics(a,b)            NOERROR
#define CHK_HrGetFolderMetrics(a,b,c,d,e,f)     NOERROR
#define CHK_CloseFolderMetrics(a)               NOERROR
#define CHK_HrJSOpen(a,b,c,d,e)           NOERROR
#define CHK_HrJSCollectDataPoint(a,b,c)   NOERROR
#define CHK_HrJSGetValue(a,b,c,d,e)       NOERROR
#define CHK_JSClose(a)                    NOERROR
#define CHK_HrFileTimeToSeconds(a,b)            NOERROR

#else

#ifdef __cplusplus
extern "C" {
#endif

//$--CHK_HrOpenFolderMetrics----------------------------------------------------
//  Check the parameters for HrOpenFolderMetrics().
// -----------------------------------------------------------------------------
__inline static HRESULT CHK_HrOpenFolderMetrics(
                                        // RETURNS: HRESULT
    IN LPMAPIFOLDER lpFolder,           // pointer to target mapi folder
    OUT HFLDMTRC *phFolderMetrics)      // receives handle to folder metric
{
    HRESULT hr = NOERROR;

	if (!TEST_IUNKNOWN_PTR(lpFolder))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

	if (!TEST_WRITE_PTR(phFolderMetrics, sizeof(*phFolderMetrics)))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

cleanup:
    return(hr);
}


//$--CHK_HrGetFolderMetrics---------------------------------------------------------
//  Check the parameters for HrGetFolderMetrics().
// -----------------------------------------------------------------------------
__inline static HRESULT CHK_HrGetFolderMetrics(
                                        // RETURNS: HRESULT
    IN HFLDMTRC hFolderMetrics,         // handle created from rcOpenFolderMetrics
    IN FILETIME *pftNow,                // Current time expressed as FILETIME
    IN DWORD fMetric,                   // Flags for metric requested. May
                                        //  be or'ed combination of:
                                        //     FM_CMESSAGES
                                        //     FM_LONGEST_WAIT
                                        //     FM_TOTAL_WAIT
    OUT DWORD *pcMessages,              // If requested, recieves the number 
                                        // of messages in folder. 0 otherwise
    OUT FILETIME *pftLongestWait,       // If requested, receives the longest
                                        // wait of messages currently in folder.
    OUT FILETIME *pftTotalWait)         // If requested, receives the total
                                        // wait of all messages in folder.
{
    HRESULT hr = NOERROR;

    if (hFolderMetrics == NULL)
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

	if (!TEST_READ_PTR(pftNow, sizeof(*pftNow)) || 
		(pftNow->dwLowDateTime == 0 && pftNow->dwHighDateTime == 0))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

    if (!TEST_WRITE_PTR(pcMessages, sizeof(*pcMessages)))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

    if (!TEST_WRITE_PTR(pftLongestWait, sizeof(*pftLongestWait)))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

    if (!TEST_WRITE_PTR(pftTotalWait, sizeof(*pftTotalWait)))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

cleanup:
    return(hr);
}


//$--CHK_CloseFolderMetrics-----------------------------------------------------
//  Check the parameters for CloseFolderMetrics().
// -----------------------------------------------------------------------------
__inline static HRESULT CHK_CloseFolderMetrics(
                                        // RETURNS: HRESULT
    IN HFLDMTRC hFolderMetrics)         // handle generated by OpenFolderMetric
{
    HRESULT hr = NOERROR;

    if (hFolderMetrics == NULL)
	{
		HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

cleanup:
    return(hr);
}


//$--CHK_HrJSOpen---------------------------------------------------------
//  Check the parameters for HrJSOpen().
// -----------------------------------------------------------------------------
__inline static HRESULT CHK_HrJSOpen(
                                // RETURNS: HRESULT
    IN JSWINDOWTYPE enType,     // The type of window to open
    IN FILETIME *pftNow,        // The current time expressed as a FILETIME
    IN FILETIME *pftResolution, // The resolution of the window. The
                                // window will jump in intervals of this
                                // size.
    IN DWORD dwWindowDuration,  // Duration of window expressed in resoution
                                // units.
    OUT HJSWINDOW *phJSWindow)  // Receives handle to newly opened window.
{
    HRESULT hr = NOERROR;

    if (enType < 0 || enType >= JSWINDOW_LAST)
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

	if (!TEST_READ_PTR(pftNow, sizeof(*pftNow)) || 
		(pftNow->dwLowDateTime == 0 && pftNow->dwHighDateTime == 0))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

	if (!TEST_READ_PTR(pftResolution, sizeof(*pftResolution)) || 
		(pftResolution->dwLowDateTime == 0 && 
		pftResolution->dwHighDateTime == 0))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

    if (!TEST_WRITE_PTR(phJSWindow, sizeof(*phJSWindow)))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

cleanup:
    return(hr);
}


//$--CHK_HrJSCollectDataPoint---------------------------------------------
//  Check the parameters for HrJSCollectDataPoint().
// -----------------------------------------------------------------------------
__inline static HRESULT CHK_HrJSCollectDataPoint(
                                        // RETURNS: HRESULT
    IN HJSWINDOW hJSWindow,             // Handle to TARGET JSWindow
    IN FILETIME *pftNow,                // Current time expressed as FILETIME
    IN DWORD dwValue)                   // Value of data point to add
{
    HRESULT hr = NOERROR;

    if (hJSWindow == NULL)
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

	if (!TEST_READ_PTR(pftNow, sizeof(*pftNow)) || 
		(pftNow->dwLowDateTime == 0 && pftNow->dwHighDateTime == 0))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

cleanup:
    return(hr);
}


//$--CHK_HrJSGetValue-----------------------------------------------------
//  Check the parameters for HrJSGetValue().
// -----------------------------------------------------------------------------
__inline static HRESULT CHK_HrJSGetValue(
                                        // RETURNS: HRESULT
    IN HJSWINDOW hJSWindow,             // Hand of window.
    IN FILETIME *pftNow,                // Current time expressed as FILETIME
    OUT DWORD *pdwWindowValue,          // Window value
    OUT DWORD *pdwFractionCompleteNum,  // Fraction of window that was filled
                                        // numerator.
    OUT DWORD *pdwFractionCompleteDen)  // Fraction of window that was filled
                                        // denominator.
{
    HRESULT hr = NOERROR;

    if (hJSWindow == NULL)
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

	if (!TEST_READ_PTR(pftNow, sizeof(*pftNow)) || 
		(pftNow->dwLowDateTime == 0 && pftNow->dwHighDateTime == 0))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

    if (!TEST_WRITE_PTR(pdwWindowValue, sizeof(*pdwWindowValue)))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

    if (!TEST_WRITE_PTR(pdwFractionCompleteNum, 
    	sizeof(*pdwFractionCompleteNum)))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

    if (!TEST_WRITE_PTR(pdwFractionCompleteDen, 
    	sizeof(*pdwFractionCompleteDen)))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

cleanup:
    return(hr);
}


//$--CHK_JSClose----------------------------------------------------------
//  Check the parameters for JSClose().
// -----------------------------------------------------------------------------
__inline static HRESULT CHK_JSClose(
                                        // RETURNS: HRESULT
    IN HJSWINDOW hJSWindow)             // handle of window to close
{
    HRESULT hr = NOERROR;

    if (hJSWindow == NULL)
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

cleanup:
    return(hr);
}


//$--CHK_HrFileTimeToSeconds----------------------------------------------------
//  Check the parameters for HrFileTimeToSeconds().
// -----------------------------------------------------------------------------
__inline static HRESULT CHK_HrFileTimeToSeconds(
                                        // RETURNS: HRESULT
    IN FILETIME *pft,                   // file time to convert 
    OUT DWORD *pdwSec)                  // receives time in seconds (0 if error)
{
    HRESULT hr = NOERROR;

    if (!TEST_READ_PTR(pft, sizeof(*pft)))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

    if (!TEST_WRITE_PTR(pdwSec, sizeof(*pdwSec)))
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

cleanup:
    return(hr);
}

#ifdef __cplusplus
}  // extern "C"
#endif

#endif /* DEBUG */
