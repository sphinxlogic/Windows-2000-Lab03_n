<html>
<head>
<title>Microsoft Platform SDK - Migrate to Win64
</title>
<style type="text/css">
<!--
.sidenav {
  color:#ffffff;
  text-decoration:none;
}
a:hover {
  color:#cc0000;
}
-->
</style>
</head>
<body bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#800080" alink="#cc0000" TOPMARGIN=0>
<!-- Begin datestamp table -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr valign="top" align="right">
<td width="100%">
<font face="Verdana, Arial, Helvetica" size="2" color="#666666">
March 1999
</font>
</td>
</tr>
</table>
<!-- End datestamp table -->
<!-- Begin Body Table -->
<!-- Start Main Content Cell -->
<p>
<h1>Win32 to Win64 Migration on Alpha - Tips From the Front Lines
</h1>

<h2>Introduction
</h2>
<p>
This article attempts to illustrate some of the coding practices for writing
portable Win32/Win64 code. Essential reading on Win64 migration is also contained in the articles 
<A href="getready.html">
<em>Getting Ready for 64-bit Windows
</em>
</a> and 
<A href="techdocs.html"><em>Designing 64-bit-Compatible Interfaces</em></a>, both from Microsoft.
</p>
<p>
The two primary areas of concern when making your code 32/64-bit portable or "64-bit clean" are:
<ul type=disc>
<li>
Address calculations
<br>
<br>
<li>
Pointer math
</li>
</ul>
<p>
For many reasons, developers have stored addresses in a 
<b>ULONG
</b> (32-bit unsigned integer). And why not? After all, an address, a pointer, and a 
<b>ULONG
</b> are all just 32-bit numbers, and they fit perfectly in a 
<b>ULONG
</b>. This is no longer
 true in the 64-bit world. In Win64, an address and a 
<b>ULONG
</b> are not treated the same way.
</p>
<p>
While a ULONG continues to remain a 32-bit value, all pointers are now 64-bit values, including pointers to 32-bit values.
</p>
<h2>Storing a 64-Bit Value
</h2>
<p>
To store a 64-bit pointer value, use 
<b>ULONG_PTR
</b>.
</p>
<p>
<b>ULONG_PTR
</b> is an unsigned integer conditionally large enough to hold a pointer value. It is 32 bits when compiled for Win32 and 64 bits when compiled for Win64.
</p>
<h2>Examples
</h2>
<p>
The following two examples show real-world code ported to Win64. Commentary on the steps to make the code 64-bit clean are included.
</p>
<h3>Example 1: Getting an Address
</h3>
<p>
The following code illustrates the 32-bit/64-bit portable use of 
<b>ULONG_PTR
</b> compared to 
<b>ULONG
</b> when getting an address.
</p>
<h4>ULONG&nbsp; // the 32-bit-only way
</h4>
<pre>
<code>ULONG getAnAddress( )
Int *somePointer
Return( (
<span class=cfe>
<b>ULONG
</b>
</span>) somePointer );
</code>
</pre>
<h4>ULONG_PTR&nbsp; // the 32-bit and 64-bit portable way
</h4>
<pre>
<code>ULONG_PTR getAnAddress( )
Int *somePointer
Return( (
<span class=cfe>
<b>ULONG_PTR
</b>
</span>) somePointer );
</code>
</pre>
<h3>Example 2: Calculating an Address
</h3>
<p>
The following code illustrates the use of 
<b>ULONG_PTR
</b> compared to 
<b>ULONG
</b> when calculating an address.
</p>
<h4>ULONG&nbsp; // the 32-bit-only way
</h4>
<pre>
<code>Int *somePointer;
Int *someOtherPointer;
somePointer = (int *)( (
<span class=cfe>
<b>ULONG
</b>
</span>)someOtherPointer + 0x20 );
</code>
</pre>
<h4>ULONG_PTR&nbsp; // the 32-bit and 64-bit portable way
</h4>
<pre>
<code>Int *somePointer;
Int *someOtherPointer;
somePointer = (int *)( (
<span class=cfe>
<b>ULONG_PTR
</b>
</span>)someOtherPointer + 0x20 );
</code>
</pre>
<h2>Common Compiler Errors When Migrating to Win64 on Alpha
</h2>
<p>
This section illustrates the typical compiler errors that occur when migrating from an existing Win32 code base to 
Win64. These examples happen to be from system-level HAL code, although the concepts are directly applicable to user-level 
code.
</p>
<h3>Warning C4311: 'type cast' : pointer truncation from 'void *__ptr64 ' to 'unsigned long '
</h3>
<p class=label>
<b>Offending Line
</b>
</p>
<pre>
<code>pPciAddr-&gt;u.AsULONG = (
<span class=cfe>
<b>ULONG
</b>
</span>) CIA_PCI_CONFIG_BASE_QVA;
</code>
</pre>
<p class=label>
<b>Description
</b>
</p>
<p>
<b>PtrToUlong()
</b> is an inline function or macro, depending on your usage. It truncates a pointer to a 
<b>ULONG
</b>. Although 32-bit pointers are not affected, the upper half of a 64-bit pointer is simply chopped off.
</p>
<p>
The value 
<b>CIA_PCI_CONFIG_BASE_QVA
</b> is declared as a 
<b>PVOID
</b>. The (
<b>ULONG
</b>) cast works in the 32-bit world, but results in an error in the 64-bit world. What is needed is to get a 64-bit pointer into a 
<b>ULONG
</b>, because changing the definition of the union that 
<code>pPciAddr-&gt;u.AsULONG
</code> is defined in changes far too much code.
</p>
<p>
Using the macro 
<b>PtrToUlong()
</b> to convert the 64-bit 
<b>PVOID
</b> to the needed 
<b>ULONG
</b> is OK because the programmer has knowledge about the specific value of&nbsp; 
<b>CIA_PCI_CONFIG_BASE_QVA
</b>. In this case, this pointer will never have data in the upper 32 bits.
</p>
<p class=label>
<b>The Fix
</b>
</p>
<pre>
<code>pPciAddr-&gt;u.AsULONG = 
<span class=cfe>
<b>PtrToUlong
</b>
</span>(CIA_PCI_CONFIG_BASE_QVA);
</code>
</pre>
<h3>Warning C4311: 'type cast' : pointer truncation from 'struct _ERROR_FRAME *__ptr64 ' to 'unsigned long '
</h3>
<p class=label>
<b>Offending Line
</b>
</p>
<pre>
<code>KeBugCheckEx( DATA_BUS_ERROR,0,0,0,(
<span class=cfe>
<b>ULONG
</b>
</span>)PUncorrectableError );
</code>
</pre>
<p class=label>
<b>Description
</b>
</p>
<p>
The problem in this code is that the last parameter to this function, in this case, is a pointer to a data structure. 
Because 
<code>PuncorrectableError
</code> is a pointer, it changes size with the 32- or 64-bit models. The prototype for 
<b>KeBugC
heckEx()
</b> was changed so that the last parameter is a 
<b>ULONG_PTR
</b>. As a result, it's necessary to case our function pointer to a 
<b>ULONG_PTR
</b> as well.
</p>
<p>
You might ask why 
<b>PVOID
</b> was not used as the last parameter. Depending on the context of the call, the last parameter may be something other 
than a pointer or perhaps an error code.
</p>
<p class=label>
<b>The Fix
</b>
</p>
<pre>
<code>KeBugCheckEx( DATA_BUS_ERROR,0,0,0,(
<span class=cfe>
<b>ULONG_PTR
</b>
</span>)PUncorrectableError );
</code>
</pre>
<h3>Warning C4244: '=' : conversion from 'struct _CONFIGURATION_COMPONENT *__ptr64 ' to 'struct _CONFIGURATION_COMPONENT *', possible loss of data
</h3>
<p class=label>
<b>Offending Line
</b>
</p>
<pre>
<code>Component = &amp;CurrentEntry-&gt;ComponentEntry;
</code>
</pre>
<p class=label>
<b>Description
</b>
</p>
<p>
In this code, the function declared the variable 
<code>Component
</code> as a 
<code>PCONFIGURATION_COMPONENT
</code>.
</p>
<p>
Later in the code, the variable is used in the following assignment that appears correct:
</p>
<pre>
<code>Component = &amp;CurrentEntry-&gt;ComponentEntry;
</code>
</pre>
<p>
The problem, however, is the type 
<code>PCONFIGURATION_COMPONENT
</code>. The definition is:
</p>
<pre>
<code>typedef struct __CONFIGURATION_COMPONENT {
...
...
} CONFIGURATION_COMPONENT, * POINTER_32 PCONFIGURATION_COMPONENT;
</code>
</pre>
<p>
The type definition 
<code>PCONFIGURATION_COMPONENT
</code> gives us a 32-bit pointer in both 32-bit and 64-bit models because it is declared 
<b>POINTER_32
</b>. The original designer of this structure knew it was going to be used in a 32-bit context in
 the BIOS and expressly defined it for that use. This code works fine in 32-bit Windows NT because the pointers happen 
to be 32-bit. In the Win64 world, it does not work because the code is in 64-bit context. 
</p>
<p>
To work around this, use 
<code>CONFIGURATION_COMPONENT *
</code> rather than the 32-bit 
<code>PCONFIGURATION_COMPONENT
</code>. It is important to clearly understand the purpose of the code. If this code is intended to touch 32-bit BIOS 
or System space, this fix will not work.
</p>
<p>
<b>POINTER_32
</b> is defined in Ntdef.h and Winnt.h (both in the SDK).
</p>
<pre>
<code>#ifdef (__AXP64__)
#define POINTER_32 _ptr32
#else
#define POINTER_32
#endif
</code>
</pre>
<p class=label>
<b>The Fix
</b>
</p>
<p>
Use 
<code>CONFIGURATION_COMPONENT *
</code> rather than 
<code>PCONFIGURATION_COMPONENT
</code>
</p>
<pre>
</pre>
<h3>Warning C4242: '=' : conversion from '__int64 ' to 'unsigned long ', possible loss of data
</h3>
<p class=label>
<b>Offending Code
</b>
</p>
<pre>
<code>ARC_STATUS HalpCopyNVRamBuffer (
IN PCHAR NvDestPtr,
IN PCHAR NvSrcPtr,
IN 
<span class=cfe>
<b>ULONG
</b>
</span> Length )
{
<span class=cfe>
<b>ULONG
</b>
</span> PageSelect1, ByteSelect1; // Dest Pointer Page &amp; offset
ByteSelect1 = (
<span class=cfe>
<b>NvDestPtr
</b>
</span> - (PUCHAR)HalpCMOSRamBase) &amp; CONFIG_RAM_BYTE_MASK;
</code>
</pre>
<p class=label>
<b>Offending Line 
</b>
</p>
<pre>
<code>ByteSelect1 = (
<span class=cfe>
<b>NvDestPtr
</b>
</span> - (PUCHAR)HalpCMOSRamBase) &amp; CONFIG_RAM_BYTE_MASK;
</code>
</pre>
<p class=label>
<b>Description
</b>
</p>
<p>
This warning is generated because the calculation is using 64-bit values, in this case pointers, and placing the result in a 32-bit 
<b>ULONG
</b>.
</p>
<p>
Typecasting the result lets the compiler know you are sure about the result. That being said, make certain you understand the calculation and really are sure it will fit in a 32-bit 
<b>ULONG
</b>.
</p>
<p>
If the result may not fit in a 32-bit 
<b>ULONG
</b>, change the base type of the variable that will hold the result.
</p>
<p class=label>
<b>The Fix
</b>
</p>
<p>
Type cast the result of the calculation to a 
<b>ULONG
</b> as shown here:
</p>
<pre>
<code>ByteSelect1 = (
<span class=cfe>
<b>ULONG
</b>
</span>)(NvDestPtr - (PUCHAR)HalpCMOSRamBase) &amp; CONFIG_RAM_BYTE_MASK;
</code>
</pre>
<h3>Warning C4311: 'type cast' : pointer truncation from 'void *__ptr64 ' to 'unsigned long '
</h3>
<p>
As explained later in the description section, a number of lines are "offending" in the following code due to pointer problems.
<b> 
</b>
</p>
<p class=label>
<b>Offending Code
</b>
</p>
<pre>
<code>
<span class=cfe>
<b>ULONG
</b>
</span> HalpMapDebugPort(
IN 
<span class=cfe>
<b>ULONG
</b>
</span> ComPort,

OUT 
<span class=cfe>
<b>PULONG
</b>
</span> ReadQva,

OUT 
<span class=cfe>
<b>PULONG
</b>
</span> WriteQva
)
{
<span class=cfe>
<b>ULONG
</b>
</span> ComPortAddress;

// Compute the port address, based on the desired com port.
// NOTE THE KEY WORD HERE IS ADDRESS ! 
<span class=cfe>
<b>ULONG
</b>
</span> PortQva;


switch( ComPort ){

case 1:
ComPortAddress = COM1_ISA_PORT_ADDRESS;
   break;

case 2:
default:
ComPortAddress = COM2_ISA_PORT_ADDRESS;
}
PortQva = (
<span class=cfe>
<b>ULONG
</b>
</span>)HAL_MAKE_QVA(CIA_PCI_SPARSE_IO_PHYSICAL) + 

// Return the QVAs for read and write access.

ComPortAddress;

*ReadQva = PortQva;
*WriteQva = PortQva;
return ComPortAddress;
}
</code>
</pre>
<p class=label>
<b>The Fix
</b>
</p>
<pre>
<code>
<span class=cfe>
<b>ULONG_PTR
</b>
</span> HalpMapDebugPort(
IN 
<span class=cfe>
<b>ULONG
</b>
</span> ComPort,
OUT P
<span class=cfe>
<b>ULONG_PTR
</b>
</span> ReadQva,
OUT P
<span class=cfe>
<b>ULONG_PTR
</b>
</span> WriteQva
)
{
<span class=cfe>
<b>ULONG_PTR
</b>
</span> ComPortAddress;
<span class=cfe>
<b>ULONG_PTR
</b>
</span> PortQva;

switch( ComPort ){

// Compute the port address, based on the desired com port.

case 1:

ComPortAddress = COM1_ISA_PORT_ADDRESS;
   break;

case 2:
default:

ComPortAddress = COM2_ISA_PORT_ADDRESS;

}
PortQva = 
  (
<span class=cfe>
<b>ULONG_PTR
</b>
</span>)HAL_MAKE_QVA(CIA_PCI_SPARSE_IO_PHYSICAL) + ComPortAddress;
*ReadQva = PortQva;
*WriteQva = PortQva;
return ComPortAddress;
}

// Return the QVAs for read and write access.
</code>
</pre>
<p class=label>
<b>Description:
</b>
</p>
<p>
This is the first time we have seen the new type 
<b>PULONG_PTR
</b>, which is a pointer to a 
<b>ULONG_PTR
</b>. 
</p>
<p>
<b>PULONG_PTR
</b> is a pointer that is itself 32 bits in Win32 and 64 bits in Win64. It points to an unsigned integer, 
<b>ULONG_PTR
</b>, that is 32 bits in Win32 and 64 bits in Win64.
</p>
<p>
This entire function is dealing with addresses as integers, necessitating the need to type those integers in a portable way. All the local variables, intermediate values in calculations, and return values become 32/64-bit convertible types.
</p>
<h3>Warning C4311: 'type cast' : pointer truncation from 'void *__ptr64 ' to 'unsigned long '
</h3>
<p class=label>
<b>Offending Code
</b>
</p>
<pre>
<code>BOOLEAN
HalpMapIoSpace (
VOID
)
{
PVOID PciIoSpaceBase;
PciIoSpaceBase = HAL_MAKE_QVA( CIA_PCI_SPARSE_IO_PHYSICAL );

//Map base addresses in QVA space.

HalpCMOSRamBase = (PVOID)((
<span class=cfe>
<b>ULONG
</b>
</span>)PciIoSpaceBase + CMOS_ISA_PORT_ADDRESS);
</code>
</pre>
<p class=label>
<b>Offending Line
</b>
</p>
<pre>
<code>HalpCMOSRamBase = (PVOID)((
<span class=cfe>
<b>ULONG
</b>
</span>)PciIoSpaceBase + CMOS_ISA_PORT_ADDRESS);

//Map CMOS RAM address.
</code>
</pre>
<p class=label>
<b>Description
</b>
</p>
<p>
Good programming practices really pay off here. Even though the programmer has insider knowledge that all QVA (Quasi Virtual Address) values are really 32-bit values at this stage, and will actually fit in a 
<b>ULONG
</b>, it is much more consistent to treat all addresses as 
<b>ULONG_PTR
</b> values when possible.
</p>
<p>
The pointer 
<b>PciIoSpace
</b> holds the QVA that is created in the macro 
<code>HAL_MAKE_QVA()
</code>. This macro returns a 64-bit value with the top 32 bits all set to zero so the math will work. The programmer 
could have simply left the code to truncate the pointer into a 
<b>ULONG
</b>, but this practice is discouraged to enhance code maintainability and portability. For example, the contents of a QVA might change in the future to use some of the upper bits at this level, breaking the code.
</p>
<p>
<B>
<b>Important:
</b>
</B> &nbsp; Be safe and use 
<b>ULONG_PTR
</b> for all address and pointer math.
</p>
<p class=label>
<b>The Fix
</b>
</p>
<pre>
<code>HalpCMOSRamBase = (PVOID)((
<span class=cfe>
<b>ULONG_PTR
</b>
</span>)PciIoSpaceBase + CMOS_ISA_PORT_ADDRESS);
</code>
</pre>
<h3>Warning C4311: 'type cast' : pointer truncation from 'void *__ptr64 ' to 'unsigned long '
</h3>
<p class=label>
<b>Offending Code
</b>
</p>
<pre>
<code>PVOID
HalDereferenceQva(
PVOID Qva,
INTERFACE_TYPE InterfaceType,
<span class=cfe>
<b>ULONG
</b>
</span> BusNumber
)
if ( ((
<span class=cfe>
<b>ULONG
</b>
</span>) Qva &amp; QVA_SELECTORS) == QVA_ENABLE ) {
Offending Line
return( (PVOID)( (
<span class=cfe>
<b>ULONG
</b>
</span>)Qva &lt;&lt; IO_BIT_SHIFT ) );
} else {
return (Qva);
}
</code>
</pre>
<p class=label>
<b>Offending Line
</b>
</p>
<pre>
<code>if ( ((
<span class=cfe>
<b>ULONG
</b>
</span>) Qva &amp; QVA_SELECTORS) == QVA_ENABLE ) {
</code>
</pre>
<p class=label>
<b>Offending Line
</b>
</p>
<pre>
<code>return( (PVOID)( (
<span class=cfe>
<b>ULONG
</b>
</span>)Qva &lt;&lt; IO_BIT_SHIFT ) );
} else {
return (Qva);
}
</code>
</pre>
<p class=label>
<b>Description
</b>
</p>
<p>
The compiler will complain about the address of the (
<b>&amp;
</b>) and left shift (
<b>&lt;&lt;
</b>) operators if they are applied to pointer types. 
<code>Qva
</code> in the above code is a PVOID. We need to cast that to an integer type to perform the 
math. Because the code must be 32/64-bit portable, 
<b>ULONG_PTR
</b> should be used rather than 
<b>ULONG
</b>. Remember, 
<b>ULONG_PTR
</b> will be 32 bits in Win32 and 64 bits in Win64.
</p>
<p class=label>
<b>The Fix
</b>
</p>
<pre>
<code>if ( ((
<span class=cfe>
<b>ULONG_PTR
</b>
</span>) Qva &amp; QVA_SELECTORS) == QVA_ENABLE ) {
  return( (PVOID)( (
<span class=cfe>
<b>ULONG_PTR
</b>
</span>)Qva &lt;&lt; IO_BIT_SHIFT ) );
</code>
</pre>
<h3>Warning C4311: 'type cast' : pointer truncation from 'void *__ptr64 ' to 'unsigned long '
</h3>
<p class=label>
<b>Offending Line
</b>
</p>
<pre>
<code>TranslatedAddress-&gt;LowPart = (
<span class=cfe>
<b>ULONG
</b>
</span>)HalCreateQva(
*TranslatedAddress,
va);
</code>
</pre>
<p class=label>
<b>Description
</b>
</p>
<p>
<code>TranslatedAddress
</code> is&nbsp; a union that looks something like the following:
</p>
<pre>
<code>Typedef union
   Struct {
      
<span class=cfe>
<b>ULONG
</b>
</span> LowPart;
      LONG Highpart;
   }
   LONGLONG QuadPart;
}
</code>
</pre>
<p>
Knowing this, and then knowing what the rest of the code might place in 
<code>Highpart
</code>, the programmer could select either solution shown in the next section. 
</p>
<p class=label>
<b>The Fix
</b>
</p>
<pre>
<code>TranslatedAddress-&gt;LowPart = 
<span class=cfe>
<b>PtrToUlong
</b>
</span>(HalCreateQva(*TranslatedAddress,va) );
</code>
</pre>
<p>
The 
<code>PtrToLong()
</code> macro simply truncates the pointer returned by 
<code>HalCreateQva()
</code> to 32bits. The programmer knows that the QVA returned by 
<code>HalCreateQva()
</code> has the upper 32 bits all set to zero anyway, and the very next line of code sets 
<code>TranslatedAddress-&gt;Highpart
</code> to zero.
</p>
<p>
With caution, the programmer could write:
</p>
<pre>
<code>TranslatedAddress-&gt;QuadPart = (LONGLONG)HalCreateQva(*TranslatedAddress,va);
</code>
</pre>
<p>
This works in this example because the programmer knows the 
<code>HalCreateQva()
</code> macro is returning 64 bits, with the upper 32 set to zero. Why not assign the whole thing at once? Just be careful 
not to leave the upper 32 bits undefined in a 32-bit environment, which this second solution may actually do.
</p>
<h3>Warning C4311: 'type cast' : pointer truncation from 'void *__ptr64 ' to 'unsigned long '
</h3>
<p class=label>
<b>Offending Code
</b>
</p>
<pre>
<code>VOID
HalpCiaProgramDmaWindow(
PWINDOW_CONTROL_REGISTERS WindowRegisters,
PVOID MapRegisterBase
)
{
CIA_WBASE Wbase;

Wbase.all = 0;
Wbase.Wen = 1;
Wbase.SgEn = 1;
Wbase.Wbase = (
<span class=cfe>
<b>ULONG
</b>
</span>)(WindowRegisters-&gt;WindowBase) &gt;&gt; 20;
</code>
</pre>
<p class=label>
<b>Offending Line
</b>
</p>
<pre>
<code>Wbase.Wbase = (
<span class=cfe>
<b>ULONG
</b>
</span>)(WindowRegisters-&gt;WindowBase) &gt;&gt; 20;
</code>
</pre>
<p class=label>
<b>Description
</b>
</p>
<p>
This line of code seems a little long-winded. Cast it to a 
<b>ULONG_PTR
</b>, then to a PVOID, then to a 
<b>ULONG
</b>? Why? Well, the problem starts with 
<code>WindowRegisters-&gt;WindowBase
</code>. This is a pointer and is now 64 bits. The code says to right-shift this value 20 bits. The compiler will not let 
us use the right-shift (
<b>&gt;&gt;
</b>) operator on a pointer; therefore, we need to cast it to some sort of integer. 
<b>ULONG_PTR
</b> is just what we
 need. The next problem is 
<code>Wbase
</code>. 
<code>Wbase
</code> is a 
<b>ULONG
</b> and is 32 bits. Having good knowledge of the code in question, the programmer knows that the 64-bit pointer 
<code>WindowRegisters-&gt;WindowBase
</code> is valid in the lower 32 bits even after being shifted. This makes use of the macro 
<code>PtrToUlong()
</code> acceptable as it will truncate the 64-bit pointer into a 32-bit 
<b>ULONG
</b>. Why do we need
 the (PVOID) cast? Because the macro 
<code>PtrToUlong()
</code> expects a pointer argument. When you look at the resulting assembler code, all this C code casting becomes just a load quad, shift right, and store long.
</p>
<p class=label>
<b>The Fix
</b>
</p>
<pre>
<code>Wbase.Wbase=
PtrToUlong ( (PVOID) ((
<span class=cfe>
<b>ULONG_PTR
</b>
</span>) (WindowRegisters-&gt;WindowBase) &gt;&gt; 20));
</code>
</pre>
<h2>Device Driver Tips
</h2>
<p>
For all the device driver writers out there who have been hiding pointers in the Irp;
</p>
<pre>
<code>Irp-&gt;IoStatus.Information = (
<span class=cfe>
<b>ULONG_PTR
</b>
</span>) someData;&nbsp; // 64 bits will fit !
</code>
</pre>
<p>
If you have been using register variables:
</p>
<pre>
<code>register 
<span class=cfe>
<b>ULONG_PTR
</b>
</span> myAddressData;&nbsp; // 64 bits will fit !
</code>
</pre>
</body>
</html>
