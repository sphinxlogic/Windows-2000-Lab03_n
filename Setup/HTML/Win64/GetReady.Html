<html>
<head>
<title>Microsoft Platform SDK - Get ready for Win64
</title>
<style type="text/css">
<!--
.sidenav {
  color:#ffffff;
  text-decoration:none;
}
a:hover {
  color:#cc0000;
}
-->
</style>
</head>
<body bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#800080" alink="#cc0000" TOPMARGIN=0>
<!-- Begin datestamp table -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr valign="top" align="right">
<td width="100%">
<font face="Verdana, Arial, Helvetica" size="2" color="#666666">
March, 1999
</font>
</td>
</tr>
</table>
<!-- End datestamp table -->
<!-- Start Full-Bleed Header Graphics with Standard Top Navigation-->
<p>
<h1>Getting Ready for 64-bit Windows
</h1>
<h2>Modifying Your Code to Support a Single Code Base for Win32 and Win64
</h2>

<p>
This document describes how to make your 32-bit source code support both 32-bit and 64-bit computing. Familiarity 
with Microsoft&#174 Win32&#174 data types will help. 

<p>
<!------------- ToC ------------ -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
    <TR><TD WIDTH="100%"><B><a href="getready.html#whatsnew"><FONT FACE="Arial, Times New Roman" SIZE=2>What's New</FONT></A></B></TD></TR>
    <TR><TD WIDTH="100%"><B><a href="getready.html#overview"><FONT FACE="Arial, Times New Roman" SIZE=2>Overview of the 64-bit shift</FONT></A></B></TD></TR>
    <TR><TD WIDTH="100%"><B><a href="getready.html#newdatatypes"><FONT FACE="Arial, Times New Roman" SIZE=2>New data types</FONT></A></B></TD></TR>
    <TR><TD WIDTH="100%"><B><a href="getready.html#workingenv"><FONT FACE="Arial, Times New Roman" SIZE=2>The working environment</FONT></A></B></TD></TR>
    <TR><TD WIDTH="100%"><B><a href="getready.html#tools"><FONT FACE="Arial, Times New Roman" SIZE=2>Tools</FONT></A></B></TD></TR>
    <TR><TD WIDTH="100%"><B><a href="getready.html#rules"><FONT FACE="Arial, Times New Roman" SIZE=2>Rules for modifying code</FONT></A></B></TD></TR>
    <TR><TD WIDTH="100%"><B><a href="getready.html#apichanges"><FONT FACE="Arial, Times New Roman" SIZE=2>API changes</FONT></A></B></TD></TR>
</TABLE>

<h2><a name="whatsnew">What's New</a>
</h2>
<p>
The Win64&trade; software development kit (SDK) and device driver kit (DDK) contain the following new data types: LONG_PTR, PLONG_PTR, ULONG_PTR, PULONG_PTR, DWORD_PTR, and PDWORD_PTR. This is primarily for type compatibility on the 32-bit system. For example, 
when a variable's type was changed to a type that was flexible dependent on the target platform, we had to make sure the new 32-bit type matched the old 32-bit type. Previously, INT_PTR and UINT_PTR were used to replace DWORDs, ULONGs, LONGs, INTs, 
and UINTs, and were typed as longs on 32-bit systems and 
<code>__int64
</code> on 64-bit systems. This led to C++ decoration being different on the 32-bit system than it was for Microsoft Windows NT&#174; version 4.0.
</p>
<p>
So we added new types so we could get exactly the same typing as we currently get on the 32-bit system, while at the same time having the ability to replace types with flexible types whose definition changes going from 32- to 64-bits.
</p>
<p>
We now have the following matrix.
</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width="32%">
<b>Type name
</b>
</td>
<td class=label width="35%">
<b>32-bit
</b>
</td>
<td class=label width="33%">
<b>64-bit
</b>
</td>
</tr>
<tr valign=top>
<td width="32%">INT_PTR 
</td>
<td width="35%">int
</td>
<td width="33%">__int64
</td>
</tr>
<tr valign=top>
<td width="32%">UINT_PTR 
</td>
<td width="35%">unsigned int
</td>
<td width="33%">unsigned __int64
</td>
</tr>
<tr valign=top>
<td width="32%">LONG_PTR 
</td>
<td width="35%">long
</td>
<td width="33%">__int64
</td>
</tr>
<tr valign=top>
<td width="32%">ULONG_PTR 
</td>
<td width="35%">unsigned long
</td>
<td width="33%">unsigned __int64
</td>
</tr>
<tr valign=top>
<td width="32%">DWORD_PTR 
</td>
<td width="35%">unsigned long
</td>
<td width="33%">unsigned__int64
</td>
</tr>
</table>
<br>
<p>
Notice that all of the 64-bit types are int64s. We have no 64-bit long data type. This, however, will not be a decoration problem because there does not exist any 64-bit software to be compatible with.
</p>
<p>
Please see basetsd.h, included with the SDK and DDK CD, for more detailed information.
</p>
<h2><a name="overview">Overview</a>
</h2>
<p>
One of the goals of the effort to create 64-bit Windows NT is to make it
possible for developers to support a single source code base for Win32
and Win64 executables. We've done a number of things in the coming
Windows 2000 to support this, which we'll cover in this overview.
</p>
<h3>Abstract Data Models
</h3>
<p>
Every application, every system, has an abstract data model. Many applications don't explicitly call out this data model, but it is still there, and, implicit or explicit, it guides the way the application's code is written. In the Win32 programming 
model, the explicit data model defines integer (int), long, and pointer data types as being 32 bits in length. It's called the 
<i>ILP32
</i> model. Most developers of Windows-based applications make this assumption without realizing it. For the histor
y of Win32, this hasn't been a problem; it was, in fact, a valid (although not necessarily safe) assumption to make.
</p>
<p>
It was clear to the designers of the 64-bit system that this assumption of parity in data type sizes would be broken. Adopting 64-bit lengths for all data types leads to everything being twice its current size. It also causes a tremendous number of p
roblems around data that's on disk or shared between applications (If every data type changes size, you must change every data type.) In addition, it was clear that most applications simply don't need to change the size of every data type. Applicatio
ns need pointers to 64-bit data, and they need the ability to have 64-bit data types in selected other cases, but it's simply not useful to have everything expand to 64 bits.
</p>
<p>
All of these considerations led us to select an abstract data model for Win64 that's called 
<i>LLP64 
</i>(or P64).
<i> 
</i>In the LLP64 data model, only pointers expand to 64 bits, and all other basic data types (int and long) stay 32 bits.
</p>
<h3>Programming in the LLP64 (P64) Model
</h3>
<p>
Most of the code running on the 64-bit platform will be code that is ported from Win32, which uses the ILP32 model. It is a major goal that the same source, carefully written, be capable of running on both Win32 and Win64. How does defining the data 
model make this easier?
</p>
<p>
The answer, of course, is that it doesn't. However, defining the data model to not affect any basic data types except pointers is the first step. The second step is to define a set of new data types that allow developers to automatically size their 
pointer-related data (things like the length of the data targeted by the pointer). This allows data associated with pointers to change size with the change in pointer size as applications are compiled for a 32- or 64-bit platform. Basic data types 
stay 32-bit, so data on disk doesn't change in size; data structures that are shared over a wire or through memory-mapped structures also don't change size. This relieves developers of most of the effort involved in potential 32-bit to 64-bit ports.
</p>
<p>
These new data types have been back-propagated to the Win32 development kits
and some Windows application programming interfaces (APIs), starting with
Beta 2 of Windows 2000, so that developers can start using them now. We are
in the process of porting all Windows APIs.
</p>
<p>
These new types derive from the basic C-language integer and long types, so embedding these new types in the Windows APIs doesn't affect existing code. They can be used to make new and existing Win32 code ready for Win64.
</p>
<h3><a name="newdatatypes">The Data Types</a>
</h3>
<p>
So, what are the data types? There are three classes of new data types: pointer-precision types, fixed-precision data types, and specific-precision pointers.
</p>
<h4>Fixed precision
</h4>
<p>
Fixed-precision data types are the same lengths in Win32 and Win64. To help you remember this, they have their precision embedded in the data type:
<ul type=disc>
<li>
<b>INT32
</b> and 
<b>INT64
</b>: Fixed-precision 32- and 64-bit signed integers.
<br>
<br>
<li>
<b>LONG32
</b> and 
<b>LONG64
</b>: Fixed-precision 32- and 64-bit signed longs.
<br>
<br>
<li>
<b>WORD32
</b> and 
<b>WORD64
</b>: Fixed-precision 32- and 64-bit unsigned integers.
<br>
<br>
<li>
<b>UINT32
</b> and 
<b>UINT64
</b>: Unsigned versions of INT32 and INT64.
<br>
<br>
<li>
<b>ULONG32
</b> and 
<b>ULONG64
</b>: Unsigned versions of LONG32 and LONG64.
</li>
</ul>
<h4>Pointer precision
</h4>
<p>
As the pointer's precision changes (that is, as it becomes 32 bits with Win32 and 64 bits with Win64), these data types change precision to correspond to the pointer. That makes it safe to cast pointers to the xxxx_PTR type to do pointer arithmetic; 
if the pointers are 64 bits, xxxx_PTR is 64 bits. The count variables also change size (remember, this happens at compile time) to hold a count of the maximum size a pointer can point to:
<ul type=disc>
<li>
<b>LONG_PTR
</b> and 
<b>ULONG_PTR
</b>: Pointer-precision longs, signed and unsigned.
<br>
<br>
<li>
<b>DWORD_PTR
</b>: Pointer-precision unsigned long.
<br>
<br>
<li>
<b>INT
</b>_
<b>PTR
</b> and 
<b>UINT_PTR
</b>: Pointer-precision integers, signed and unsigned.
<br>
<br>
<li>
<b>SSIZE
</b>_
<b>T
</b> and 
<b>SIZE_T
</b>: Pointer-precision counts (SSIZE_T is signed).
</li>
</ul>
<p>
We've also added some new pointer types &#151; these explicitly size the pointer. Note the cautions in the later sections about pointers in Win64: If you declare the pointer to be 32 bits, it is made 32 bits by truncating a 64-bit pointer. (All pointers are
 64 bits on the 64-bit platform.)
<ul type=disc>
<li>
<b>__ptr64
</b> (64-bit pointer): In Win32, this will be created by sign extending a 32-bit pointer. In Win64, this is a native pointer. Note that no assumptions should be made about pointer sign bits. Since the introduction of Windows NT Enterprise 
Edition, it has not been safe to assume the state of the high pointer bit.
<br>
<br>
<li>
<b>__ptr32
</b> (32-bit pointer): In Win64, this will be created by truncating a 64-bit pointer. In Win32, this is a native pointer.
</li>
</ul>
<h4>Why use these types?
</h4>
<p>
These types were added to the Windows NT environment to allow applications to get ready for 64 bits well before the introduction of the 64-bit platform. They also have an added advantage in that their adoption requires that developers scan their code
 for potentially unsafe pointer, polymorphic, or data definition usage and fix any unsafe usage. This makes code more robust. When a type like ULONG_PTR is being used for a variable, it's clear that it will be used for casting pointers for arithmetic
 or for polymorphic operations. This isn't possible to indicate in the native Windows data types today. (It can be done through derived type naming and it can be done through adopted Hungarian notation, but both of these require discipline on the 
part of the developer and the definer of the data types.)
</p>
<p>
So, the bottom line: Adopting these data types will make your code more robust and ready for Win64. Add these data types to your code, test it with the existing Win32, and Win64 is just a recompile away.
</p>
<h2><a name="workingenv">The Environment</a>
</h2>
<p>
Developers working on code for Win64 will find the working environment to be virtually identical to that in Win32. The APIs are the familiar Windows APIs. Many of these APIs have modifications that allow them to "float" their precision to that of the
 platform they are running on. What this means to the developer is simplicity and a short learning curve &#151; writing code for Win64 is just like writing code for Win32.
</p>
<p>
The Platform SDK includes the new data types that allow pointers and pointer-associated variables to float their precision with the platform. This means that developers can write a single source base and compile it to run natively with Win32 or Win64
. This strategy reduces the cost of developing applications that leverage 64-bit hardware, such as the forthcoming IA-64 chip (the Merced) from Intel&reg;, to a testing effort.
</p>
<p>
If code is developed now for Win32, it can simply be recompiled and tested
with Win64 when available. Application developers have more time and more
test coverage for making their application 64-bit ready if they adopt the
new data-type conventions over the next year. If you're making maintenance
changes or Windows 2000-specific changes to your code, you should change
the data definitions at the same time to conform with the new Windows API
definitions. Test the application, run it through the 64-bit syntax checker (described
below), and the application is ready to go 64-bit when the platform is available.
</p>
<h2><a name="tools">The Tools</a>
</h2>
<p>
The following section describes the tools available for you to use in making your application 64-bit ready.
</p>
<h3>Include Files
</h3>
<p>
You'll use the same tools for creating64-bit ready applications that you used for
creating Win32 applications: the APIs are virtually identical and the include
files you use stay the same. The big difference is the inclusion of a new file,
Basetsd.h, in the Windows.h include set. Basetsd.h includes all the new data-type
definitions that you'll use to make your application word-size insensitive.
</p>
<h3>New Data Types
</h3>
<p>
The following new data type definitions, which are key to writing applications that will run on both 32- and 64-bit platforms, have been added to the Basetsd.h include file described above.
</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width="23%">
<b>Type name
</b>
</td>
<td class=label width="77%">
<b>Definition/usage
</b>
</td>
</tr>
<tr valign=top>
<td width="23%">LONG32 
<br>
INT32
</td>
<td width="77%">32-bit signed.
<br>
Use for variables that must be specifically 32 bits in length.
</td>
</tr>
<tr valign=top>
<td width="23%">LONG64 
<br>
INT64
</td>
<td width="77%">64-bit signed.
<br>
Use for variables that must be specifically 64 bits in length.
</td>
</tr>
<tr valign=top>
<td width="23%">ULONG32 
<br>
UINT32
</td>
<td width="77%">32-bit unsigned.
<br>
Use for unsigned variables that must be specifically 32 bits in length.
</td>
</tr>
<tr valign=top>
<td width="23%">ULONG64 
<br>
UINT64
</td>
<td width="77%">64-bit unsigned.
<br>
Use for unsigned variables that must be specifically 64 bits in length.
</td>
</tr>
<tr valign=top>
<td width="23%">LONG_PTR
</td>
<td width="77%">Signed long, pointer precision.
<br>
Used when casting a pointer to long to perform pointer arithmetic.
</td>
</tr>
<tr valign=top>
<td width="23%">ULONG_PTR
</td>
<td width="77%">Signed long, pointer precision.
<br>
Used when casting a pointer to an unsigned long to perform pointer arithmetic.
</td>
</tr>
<tr valign=top>
<td width="23%">DWORD_PTR
</td>
<td width="77%">Signed long, pointer precision.
<br>
Used when casting a pointer to an unsigned long to perform pointer arithmetic.
</td>
</tr>
<tr valign=top>
<td width="23%">INT_PTR
</td>
<td width="77%">Signed int, pointer precision.
<br>
Used when casting a pointer to an integer to perform pointer arithmetic.
</td>
</tr>
<tr valign=top>
<td width="23%">UINT_PTR
</td>
<td width="77%">Unsigned int, pointer precision.
<br>
Used when casting a pointer to an unsigned integer to perform pointer arithmetic.
</td>
</tr>
<tr valign=top>
<td width="23%">SIZE_T
</td>
<td width="77%">Unsigned count, pointer precision.
<br>
Used when a count of what the pointer points to is needed; precision follows pointer size (32 bits on 32-bit platform, 64 bits on 64-bit platform).
</td>
</tr>
<tr valign=top>
<td width="23%">SSIZE_T
</td>
<td width="77%">Signed count, pointer precision.
<br>
Used when a count of what the pointer points to is needed; precision follows pointer size (32 bits on 32-bit platform, 64 bits on 64-bit platform).
</td>
</tr>
</table>
<br>
<h3>Targeted Syntax Checker
</h3>
<p>
With the release of Beta 2 of Windows 2000, the Platform SDK will include a tool
called the Targeted Syntax Checker that you can use to find your pointer
truncation warnings, improper type casts, and other 64-bit specific problems.
Better tools will be available, but this tool will help you get started. This
syntax checker can be passed over your code very easily; setup and usage
instructions are included in the SDK. The first time you run it, this compiler will generate
a lot of pointer truncation/type mismatch warnings. Use these warnings as a guide to clean up your 
code and make your changes.
</p>
<p>
Once you've installed the compiler, you can run it on a project or set of code.  You'll get warnings similar to the following:
</p>
<pre>
<code>disk.c(2058) : warning C4311: 'type cast' : pointer truncation from
 &nbsp; 'unsigned char *' to 'unsigned long '
</code>
</pre>
<p>
The following code generated this warning: 
</p>
<pre>
<code>&nbsp;buffer = (PUCHAR)srbControl;
 (ULONG)buffer += srbControl-&gt;HeaderLength;
</code>
</pre>
<p>
To correct the warnings, you could change the code to: 
</p>
<pre>
<code>&nbsp;buffer = (PUCHAR)srbControl;
 (ULONG_PTR)buffer += srbControl-&gt;HeaderLength;
</code>
</pre>
<p>
Your goal should be to make all warnings, especially 4311 pointer-truncation warnings, disappear in all your code.
</p>
<p>
More information can be found in the 
<u>Syntax Checker</u> 
section and on the Platform SDK (where you obtained the syntax checker).
</p>
<h2><a name="rules">The Rules</a>
</h2>
<p>
Modifying your code to support both Win32 and Win64 is straightforward. You need only follow a few simple rules about casting pointers, and use the new data types in your code. The rules for pointer manipulation are as follows:
<ol>
<li>
<b>Do not cast pointers to int, long, ULONG, or DWORD.
</b>
<p class=tl>
If you must cast a pointer to test some bits, do arithmetic, set or clear bits, or otherwise manipulate its contents, use the UINT_PTR or INT_PTR abstract type. This type is an integral type that scales to the size of a pointer for both Win32 and Win
64 (for example, ULONG for Win32 and _int64 for Win64).
</p>
<p class=atl>
<B>
<b>Note
</b>
</B>&nbsp;&nbsp;&nbsp;HANDLE is really a void *, so typecasting HANDLE to ULONG to test, set, or clear the low two tagbits is an error in Win64.
</p>
<p class=tl>
If you had code written as:
</p>
<pre>
<code>&nbsp;ImageBase = (PVOID)((ULONG)ImageBase | 1);
</code>
</pre>
<p class=tl>
As a part of the Win64 porting process, you would change the code to:
</p>
<pre>
<code>&nbsp;ImageBase = (PVOID)((ULONG_PTR)ImageBase | 1);
</code>
</pre>
<p class=tl>
You should use UINT_PTR and INT_PTR where appropriate. (Where you are uncertain if they are appropriate, no harm comes of using them just in case.) Do not cast your pointers to the 32-bit types ULONG, LONG, INT, UINT, or DWORD.
</p>
<li>
<b>Use PtrToLong() or PtrToUlong() to truncate pointers.
</b>
<p class=tl>
If you absolutely must truncate a pointer to a 32-bit value, use the 
<b>PtrToLong()
</b> or 
<b>PtrToUlong()
</b> functions (found in Basetsd.h). This will disable the pointer truncation warning for the duration of your call.
</p>
<p class=atl>
<b>
<B>Important:
</B>&nbsp;&nbsp;&nbsp;
</b>Use these functions with extreme caution.
</p>
<p class=atl>
Once a pointer has passed through these functions, you should never use it as a pointer again. With Win64, you will 
have thrown away the upper 32 bits of an address, and these bits are usually needed to access the memory targeted by 
the original pointer. Using these functions without careful consideration of their effects will almost certainly 
result in fragile code.
</p>
<li>
<b>Be very careful with OUT parameters.
</b>
<p class=tl>
If you call an API that returns a pointer to you, for example:
</p>
<pre>
<code>void
foo( OUT PULONG *PointerToUlong );
</code>
</pre>
<p class=tl>
Do not call the API as:
</p>
<pre>
<code>ULONG ul;
PULONG lp;
foo((PULONG *)&amp;ul);
lp = (PULONG)ul;
</code>
</pre>
<p class=tl>
It should be called as:
</p>
<pre>
<code>PULONG lp;
foo(&amp;lp);
</code>
</pre>
<p class=tl>
Typecasting 
<code>&amp;ul
</code> to 
<code>(PULONG *)
</code> fools the compiler, but the API is still going to write a 64-bit pointer value into the memory at location 
<code>&amp;ul
</code>. This code works fine on Win32, but will cause data corruption
 on 64-bit Windows NT &#151; and it will be subtle, hard-to-find corruption. The bottom line: don't play tricks with the C code &#151; straightforward and simple is better.
</p>
<li>
<b>Be very careful with your polymorphic interfaces.
</b>
<p class=tl>
Do not invent new APIs that accept DWORD parameters for polymorphic data. If the data can be a pointer or an integral value, use the UINT_PTR or PVOID types.
</p>
<p class=atl>
<b>
<B>Important:
</B>&nbsp;&nbsp;&nbsp;
</b>Do not use DWORD for polymorphic API definitions.
</p>
<p class=atl>
An example of a bad API definition would be 
<b>RaiseException()
</b>, where the exception parameters are typed as an array of DWORDs. These should be an array of ULONG_PTRs; that way they can hold addresses or 32-bit integral values (such as NTSTATUS 
values). If you have places where you use DWORD, ULONG, or another 32-bit type in an API or structure in a polymorphic way (that is, you really want the parameter or structure member to hold an address), use UINT_PTR in place of whatever else you're 
using. This will have no impact on your 32-bit code, but will work properly on the 64-bit Windows NT platform.
</p>
<li>
<b>Use the new Get/SetWindowLongPtr and Get/SetClassLongPtr APIs.
</b>
<p class=tl>
If you have window or class private data that contains pointers, your code will need to change to use these new APIs. Prepare for this change now by using the above APIs as appropriate. Additionally, any code that refers to pointers or handles must 
be accessed using the new functions on 64-bit platforms. To aid developers in finding these cases, Winuser.h undefines these indexes: GWL_WNDPROC, GWL_HINSTANCE, GWL_HWDPARENT, GWL_USERDATA. But we add the new indexes: GWLP_WNDPROC, GWLP_HINSTANCE, GW
LP_HWNDPARENT, GWLP_USERDATA, and GWLP_ID that are valid on Win32 and Win64. For example, the following code,
</p>
<pre>
<code>SetWindowLong(hWnd, GWL_WNDPROC, (LONG)MyWndProc);
</code>
</pre>
<p class=tl>
will get an error about GWL_WNDPROC being undefined. It should be changed to:
</p>
<pre>
<code>SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)MyWndProc);
</code>
</pre>
<li>
<b>Access ALL Window and class data using FIELD_OFFSET.
</b>
<p class=tl>
It's common to see access to window data using hard-coded offsets, which clearly won't survive the transition to a 64-bit platform. Make sure you access your window and class data using the FIELD_OFFSET macro. Do not assume that the second pointer 
has an offset of 4 (as so many do).
</p>
<li>
<b>LPARAM, WPARAM, and LRESULT change size with the platform.
</b>
<p class=tl>
On the 64-bit platform, these types expand to 64 bits, because they typically hold pointers or integral types. Do not mix DWORD, ULONG, UINT, INT, int, or long with these values. Examine your usage of these types and ensure that you don't 
inadvertently truncate them during usage.
</p>
</li>
</ol>
<h2>The Syntax Checker
</h2>
<p>
The Platform SDK contains the syntax checker (which is a compiler front end) and is accompanied by the Readme64.txt file; it has the latest instructions and documentation for the syntax checker. Note that the syntax checker is a compiler front end 
(that is, it's the front end of the compiler without code generation). Additionally, you can read Readme64ddk.htm in the latest Preliminary Platform DDK.
</p>
<h3>Syntax Checker Switches and Changes
</h3>
<p>
Note that this syntax checker enables the LLP64 (P64) data model; _WIN64 is defined by default.
</p>
<p>
There is a warning option to assist porting to LLP64. The -Wp64 -W3 switch turns on the following warnings:
<ul type=disc>
<li>
<b>C4305
</b>: Truncation warning. For example, "return": truncation from "unsigned int64" to "long."
<br>
<br>
<li>
<b>C4311
</b>: Truncation warning. For example, "type cast": pointer truncation from "int*_ptr64" to "int."
<br>
<br>
<li>
<b>C4312
</b>: Conversion to bigger-size warning. For example, "type cast": conversion from "int" to "int*_ptr64" of greater size.
<br>
<br>
<li>
<b>C4318
</b>: Passing zero length. For example, passing constant zero as the length to memset.
<br>
<br>
<li>
<b>C4319
</b>: Not operator. For example, "~": zero extending "unsigned long" to "unsigned _int64" of greater size.
<br>
<br>
<li>
<b>C4313
</b>: Calling the printf() family of routines with conflicting conversion type specifiers and arguments. For example, "printf": "%p" in format string conflicts with argument 2 of type "_int64."
<br>
<br>
<li>
<b>C4244:
</b> Same as Microsoft Visual C++(r) version 5.0 warning 
<b>C4242
</b>. For example, "return": conversion from "_int64" to "unsigned int," possible loss of data.
</li>
</ul>
<h2>Additional Things to Consider
</h2>
<ul type=disc>
<li>
<code>#ifdef _WIN32 ... (Win32 code) #else ... (assume Win16 code) #endif
</code>
<br>
Obviously, on 64-bit this assumption is no longer valid.
<br>
<br>
<li>
<code>#ifdef WIN16 ... (Win16 code) #else ... (assume Win32 code) #endif
</code>
<br>
Obviously, on 64-bit this assumption is no longer valid.
<br>
<br>
<li>
Alignment issues. Given a type, TYPE_ALIGNMENT(t) will return the alignment requirements of that type. For example:
<p class=tl>
TYPE_ALIGNMENT( KFLOATING_SAVE ) == 4 on x86, 8 on Merced(tm).
<br>
TYPE_ALIGNMENT( UCHAR ) == 1 everywhere.
</p>
<p class=tl>
As an example of its use, kernel code that currently looks like this:
</p>
<pre>
<code>ProbeForRead( UserBuffer, UserBufferLength, sizeof( ULONG ));
</code>
</pre>
<p class=tl>
should probably be changed to:
</p>
<pre>
<code>ProbeForRead( UserBuffer, UserBufferLength, TYPE_ALIGN( IOCTL_STRUC ));
</code>
</pre>
</li>
</ul>
<p>
The current plan of record is that automatic fixes of kernel-mode alignment exceptions will not be turned on for 64-bit platforms, as it is currently for all 32-bit platforms. Therefore:
<ul type=disc>
<li>
Win64 does not explicitly support loading a Win32 dynamic-link library (DLL) into the address space of a native Win64 process. Additionally, Win64 does not explicitly support loading a native 64-bit DLL into the address space of a Win32 process.
<br>
<br>
<li>
In the Platform SDK documentation section of the MSDN Library, you can find "DCDMARSH-Standard Marshaling for DCOM." This tutorial sample shows you how to write custom interfaces across process and machine boundaries.
<p class=tl>
Additionally, you can learn more about COM from 
<i>Inside COM
</i>, by Dale Rogerson (Microsoft Press), and 
<i>Inside Distributed COM
</i>, by Guy Eddon (Microsoft Press).
</p>
<li>
Be careful with NOT operations with Win64. Consider the following:
<pre>
<code>UINT_PTR bar; ULONG foo;
bar = bar &amp; ~(foo - 1); 
</code>
</pre>
<p class=tl>
The problem is that ~(foo - 1) produces 0x0000 0000 xxxx xxxx and not 0xFFFF FFFF xxxx xxxx. The compiler will not detect it. You can fix this by changing the code to the following: 
</p>
<pre>
<code>bar = bar &amp; ~((UINT_PTR)foo - 1);
</code>
</pre>
<li>
Unsigned and signed operations. Consider the following:
<pre>
<code>LONG a;
ULONG b;
LONG c;

a = -10
b = 2;
c = a / b;
</code>
</pre>
<p class=tl>
The answer is an unexpectedly big one. The rule is that if either operand is 
<code>unsigned, 
</code>the result is
<code> unsigned. 
</code>In the preceding example, 
<code>a
</code> is converted to 
<code>signed
</code> and stored in 
<code>c
</code>. Both of the conversions involve no numeric manipulation.
</p>
<p class=tl>
Another example:
</p>
<pre>
<code>LONG a;
LONG b;

a = -10;
b = a / sizeof (LONG); // the answer is unexpectedly big answer.
</code>
</pre>
<p class=tl>
Another example:
</p>
<pre>
<code>LONG *pBar;
ULONG x;
LONG y;
LONG *pFoo;

pFoo = fBar + y * (x - 1);
</code>
</pre>
<p class=tl>
The problem arises because 
<code>x
</code> is 
<code>unsigned
</code>, which makes the entire expression 
<code>y * (x - 1) unsigned
</code>. This works just fine until <code>y</code> is negative, in which case 
<code>y
</code> is converted to 
<code>unsigned
</code> and 
the expression is evaluated with 32-bit precision, and then scaled and added to 
<code>pBar
</code>. Unfortunately, a 32-bit 
<code>unsigned
</code> negative number becomes a very large 64-bit positive number and produces the wrong result.
</p>
<p class=tl
>
The way to fix this is to either declare 
<code>x
</code> as 
<code>signed
</code> or explicitly 
<code>typecast
</code> it to 
<code>LONG
</code> in the expression.
</p>
</li>
</ul>
<h2><a name="apichanges">API Changes</a>
</h2>
<p>
Over time, this section will include all of the changes made to Windows APIs.
</p>
<h4>Obsolete constants
</h4>
<pre>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#undef GWL_WNDPROC
 &nbsp;&nbsp; #undef GWL_HINSTANCE
 &nbsp;&nbsp; #undef GWL_HWNDPARENT
 &nbsp;&nbsp; #undef GWL_USERDATA

 &nbsp;&nbsp; #undef GCL_MENUNAME
 &nbsp;&nbsp; #undef GCL_HBRBACKGROUND
 &nbsp;&nbsp; #undef GCL_HCURSOR
 &nbsp;&nbsp; #undef GCL_HICON
 &nbsp;&nbsp; #undef GCL_HMODULE
 &nbsp;&nbsp; #undef GCL_WNDPROC
 &nbsp;&nbsp; #undef GCL_HICONSM
 &nbsp;&nbsp; 
 &nbsp;&nbsp; #undef DWL_MSGRESULT
 &nbsp;&nbsp; #undef DWL_DLGPROC
 &nbsp;&nbsp; #undef DWL_USER
 &nbsp;&nbsp; 
</code>
</pre>
<h4>New constants
</h4>
<pre>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#define GWLP_WNDPROC (-4)
 &nbsp;&nbsp; #define GWLP_HINSTANCE (-6)
 &nbsp;&nbsp; #define GWLP_HWNDPARENT (-8)
 &nbsp;&nbsp; #define GWLP_USERDATA (-21)
 &nbsp;&nbsp; #define GWLP_ID (-12)

 &nbsp;&nbsp; #define GCLP_MENUNAME (-8)
 &nbsp;&nbsp; #define GCLP_HBRBACKGROUND (-10)
 &nbsp;&nbsp; #define GCLP_HCURSOR (-12)
 &nbsp;&nbsp; #define GCLP_HICON (-14)
 &nbsp;&nbsp; #define GCLP_HMODULE (-16)
 &nbsp;&nbsp; #define GCLP_WNDPROC (-24)
 &nbsp;&nbsp; #define GCLP_HICONSM (-34)
 &nbsp;&nbsp; 
 &nbsp;&nbsp; #define DWLP_MSGRESULT 0
 &nbsp;&nbsp; #define DWLP_DLGPROC DWLP_MSGRESULT + sizeof(LRESULT)
 &nbsp;&nbsp; #define DWLP_USER DWLP_DLGPROC + sizeof(DLGPROC)
</code>
</pre>
<h4>New APIs
</h4>
<pre>
<code>&nbsp;&nbsp;&nbsp;&nbsp;WINUSERAPI
 &nbsp;&nbsp; INT_PTR
 &nbsp;&nbsp; WINAPI
 &nbsp;&nbsp; GetWindowLongPtrA(
 &nbsp;&nbsp; HWND hWnd,
 &nbsp;&nbsp; int nIndex);
 &nbsp;&nbsp; WINUSERAPI
 &nbsp;&nbsp; INT_PTR
 &nbsp;&nbsp; WINAPI
 &nbsp;&nbsp; GetWindowLongPtrW(
 &nbsp;&nbsp; HWND hWnd,
 &nbsp;&nbsp; int nIndex);
 &nbsp;&nbsp; #ifdef UNICODE
 &nbsp;&nbsp; #define GetWindowLongPtr GetWindowLongPtrW
 &nbsp;&nbsp; #else
 &nbsp;&nbsp; #define GetWindowLongPtr GetWindowLongPtrA
 &nbsp;&nbsp; #endif // !UNICODE
 &nbsp;&nbsp; 
 &nbsp;&nbsp; WINUSERAPI
 &nbsp;&nbsp; INT_PTR
 &nbsp;&nbsp; WINAPI
 &nbsp;&nbsp; SetWindowLongPtrA(
 &nbsp;&nbsp; HWND hWnd,
 &nbsp;&nbsp; int nIndex,
 &nbsp;&nbsp; INT_PTR dwNewLong);
 &nbsp;&nbsp; WINUSERAPI
 &nbsp;&nbsp; INT_PTR
 &nbsp;&nbsp; WINAPI
 &nbsp;&nbsp; SetWindowLongPtrW(
 &nbsp;&nbsp; HWND hWnd,
 &nbsp;&nbsp; int nIndex,
 &nbsp;&nbsp; INT_PTR dwNewLong);
 &nbsp;&nbsp; #ifdef UNICODE
 &nbsp;&nbsp; #define SetWindowLongPtr SetWindowLongPtrW
 &nbsp;&nbsp; #else
 &nbsp;&nbsp; #define SetWindowLongPtr SetWindowLongPtrA
 &nbsp;&nbsp; #endif // !UNICODE
 &nbsp;&nbsp; 
 &nbsp;&nbsp; WINUSERAPI
 &nbsp;&nbsp; UINT_PTR
 &nbsp;&nbsp; WINAPI
 &nbsp;&nbsp; GetClassLongPtrA(
 &nbsp;&nbsp; IN HWND hWnd,
 &nbsp;&nbsp; IN int nIndex);
 &nbsp;&nbsp; WINUSERAPI
 &nbsp;&nbsp; UINT_PTR
 &nbsp;&nbsp; WINAPI
 &nbsp;&nbsp; GetClassLongPtrW(
 &nbsp;&nbsp; IN HWND hWnd,
 &nbsp;&nbsp; IN int nIndex);
 &nbsp;&nbsp; #ifdef UNICODE
 &nbsp;&nbsp; #define GetClassLongPtr GetClassLongPtrW
 &nbsp;&nbsp; #else
 &nbsp;&nbsp; #define GetClassLongPtr GetClassLongPtrA
 &nbsp;&nbsp; #endif // !UNICODE
 &nbsp;&nbsp; 
 &nbsp;&nbsp; WINUSERAPI
 &nbsp;&nbsp; UINT_PTR
 &nbsp;&nbsp; WINAPI
 &nbsp;&nbsp; SetClassLongPtrA(
 &nbsp;&nbsp; IN HWND hWnd,
 &nbsp;&nbsp; IN int nIndex,
 &nbsp;&nbsp; IN INT_PTR dwNewLong);
 &nbsp;&nbsp; WINUSERAPI
 &nbsp;&nbsp; UINT_PTR
 &nbsp;&nbsp; WINAPI
 &nbsp;&nbsp; SetClassLongPtrW(
 &nbsp;&nbsp; IN HWND hWnd,
 &nbsp;&nbsp; IN int nIndex,
 &nbsp;&nbsp; IN INT_PTR dwNewLong);
 &nbsp;&nbsp; #ifdef UNICODE
 &nbsp;&nbsp; #define SetClassLongPtr SetClassLongPtrW
 &nbsp;&nbsp; #else
 &nbsp;&nbsp; #define SetClassLongPtr SetClassLongPtrA
 &nbsp;&nbsp; #endif // !UNICODE
</code>
</pre>
<h4>Intrinsics
</h4>
<p>
The following interlock intrinsics are enabled:
</p>
<p class=indent>
<B>
<b>Note:
</b>
</B>&nbsp;&nbsp;&nbsp;These interlock intrinsics return the new value, not the original value.
</p>
<pre>
<code>long _InterlockedAdd(long *, long)
__int64 _InterlockedAdd64(__int64 *, __int64)
</code>
</pre>
<p class=indent>
<B>
<b>Note:
</b>
</B>&nbsp;&nbsp;&nbsp;The xxx64 intrinsics are 64-bit implementations of the LONG intrinsics.
</p>
<pre>
<code>long&nbsp;&nbsp;&nbsp; _InterlockedDecrement(long *)|
__int64 _InterlockedDecrement64(__int64 *)
long&nbsp;&nbsp;&nbsp; _InterlockedExchange(long *, long)
__int64 _InterlockedExchange64(__int64 *, __int64)
void *&nbsp; _InterlockedExchangePointer(void **, void *)
long&nbsp;&nbsp;&nbsp; _InterlockedExchangeAdd(long *, long)
__int64 _InterlockedExchangeAdd64(__int64 *, __int64)
long&nbsp;&nbsp;&nbsp; _InterlockedCompareExchange (long *, long, long)
__int64 _InterlockedCompareExchange64(__int64 *, __int64, __int64)
void *&nbsp; _InterlockedCompareExchangePointer (void **, void *, void *)
long&nbsp;&nbsp;&nbsp; _InterlockedIncrement(long *)
__int64 _InterlockedIncrement64(__int64 *)
</code>
</pre>
<p>
The following operating system (OS)/miscellaneous intrinsics are implemented:
</p>
<pre>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __break(const int)))
 &nbsp;&nbsp;&nbsp;&nbsp; void _disable(void)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __dsrlz(void)))
 &nbsp;&nbsp;&nbsp;&nbsp; void _enable(void)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __fc(__int64)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __fclrf(void)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __fsetc(int, int)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __fwb(void)))
 &nbsp;&nbsp;&nbsp;&nbsp; unsigned __int64 __getReg(int)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __isrlz(void)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __invalat(void)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __mf(void)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __mfa(void)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __ptcl(__int64, __int64)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __ptcg(__int64, __int64)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __ptcga(__int64, __int64)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __ptcrd(__int64, __int64)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __ptcri(__int64, __int64)))
 &nbsp;&nbsp;&nbsp;&nbsp; void *_rdteb(void)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __rsm(const int)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __rum(const int)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __setReg(int,unsigned __int64)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __ssm(const int)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __sum(const int)))
 &nbsp;&nbsp;&nbsp;&nbsp; void __synci(void)))
 &nbsp;&nbsp;&nbsp;&nbsp; __int64 __thash(__int64)))
 &nbsp;&nbsp;&nbsp;&nbsp; __int64 __ttag(__int64)))
</code>
</pre>
<p>
The following single precision math routines are now intrinsics (they translate to calls for now):
</p>
<pre>
<code>float cdecl acosf(float)
float cdecl asinf(float)
float cdecl atan(float)
float cdecl atan2f(float,float)
float cdecl ceilf(float)
float cdecl cosf(float)
float cdecl coshf(float)
float cdecl expf(float)
float cdecl fabsf(float)
float cdecl floorf(float)
float cdecl fmodf(float,float)
float cdecl logf(float)
float cdecl log10f(float)
float cdecl powf(float,float)
float cdecl sinf(float)
float cdecl sinhf(float)
float cdecl sqrtf(float)
float cdecl tanf(float)
float cdecl tanhf(float)
</code>
</pre>
<h2>Comments and Feedback 
</h2>
<p>
Please send your comments and feedback to 
<A href="mailto:nt64feed@microsoft.com">nt64feed@microsoft.com
</A>
<b>.
</b>
</p>
</body>
</html>
